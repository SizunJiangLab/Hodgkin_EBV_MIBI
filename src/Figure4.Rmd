---
title: "Figure 4: Spatial Analysis and Immune Profiling"
author: "Huaying Qiu"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    theme: cosmo
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width=10, fig.height=8)

```

# 1. Environment Setup

## 1.1 Libraries

```{r libraries}
library(tidyverse)
library(raster)
library(ComplexHeatmap)
library(reshape2)
library(ggplot2)
library(ggpubr)
library(class)
library(foreach)
library(doParallel)
library(cowplot)

```

## 1.2 Configuration (Paths & Constants)

Please update the paths below to match your local environment before running.

```{r config}
# File Paths
PATHS <- list(
  annotated_data = "~/Hodgkin_github/data/hodgkin_DFCI_noID.csv",
  tumor_score    = "/mnt/nfs/home/huayingqiu/hodgkinebvmibi/anchor_data/tumor_effect_score_100um.csv",
  seg_dir        = "~/hodgkinebvmibi/20220823_cHL-DFCI_Production_M060/",
  output_dir     = "~/hodgkinebvmibi/paper_figures/"
)

# Visualization Palettes
PALETTES <- list(
  # Discrete bins for spatial maps
  bin_discrete = c(
    'Tumor'        = '#E41A1C', 
    'Tumor Dense'  = '#f6adff', 
    'Tumor Sparse' = '#e1d936', 
    'Far'          = '#52bcaa'
  ),
  # Discrete scores for spatial maps
  score_discrete = c(
    'Tumor'          = '#E41A1C', 
    'Tumor Proximal' = '#393B79', 
    'Tumor Distal'   = '#5254A3', 
    'Far'            = '#6B6ECF'
  ),
  # EBV Status colors
  ebv = c(
    'Positive' = '#D55E00', 
    'Negative' = '#009E73'
  )
)

```

# 2. Helper Functions

## 2.1 Data Ingestion

```{r func_data_loading}
#' Load and Merge Clinical and Score Data
load_project_data <- function(annot_path, score_path) {
  # Load Annotation Data
  df_annot <- read_csv(annot_path, show_col_types = FALSE) %>% 
    mutate(ebv_status = factor(ebv_status, levels = c('Positive', 'Negative')))
  
  # Load Tumor Effect Score Data
  df_score <- read_csv(score_path, show_col_types = FALSE)
  
  # Merge
  merged_df <- df_score %>% 
    left_join(df_annot, by = c('pointNum', 'cellLabel', 'centroidX', 'centroidY'))
  
  return(merged_df)
}

#' Load and Organize Segmentation Masks
#' Handles specific file ordering fixes required for the dataset
prepare_masks <- function(seg_dir) {
  seg_files <- list.files(seg_dir, full.names = TRUE, recursive = TRUE, pattern = 'segmentationMap.tif')
  
  # Specific fix for swapping LN masks (Points 31/32)
  if(length(seg_files) >= 32) {
    seg_files <- replace(seg_files, c(31,32), seg_files[c(32,31)])
  }
  
  # Read masks into a list of matrices
  mask_list <- map(seg_files, ~as.matrix(raster(.x)))
  return(mask_list)
}

#' Pre-process Data for Spatial Plotting
#' Imputes missing bin values as 'Tumor'
process_annotations_for_plotting <- function(main_df) {
  processed_df <- main_df %>% 
    mutate(
      bin = ifelse(is.na(bin), 'Tumor', bin),
      bin_deriva = ifelse(is.na(bin_deriva), 'Tumor', bin_deriva)
    )
  return(processed_df)
}

```

## 2.2 Spatial Plotting

```{r func_spatial_plotting}
#' Universal Spatial Plotter
#' Generates raster maps for either discrete bins or continuous scores
#' 
#' @param point_num Integer ID of the point/image
#' @param seg_list List of segmentation matrices
#' @param data_df Dataframe containing annotations
#' @param fill_col String: Column name to map to fill color ('bin_deriva' or 'score')
#' @param fill_type String: 'discrete' or 'continuous'
#' @param palette Named vector or NA. Used if fill_type is discrete.
#' @param mask_offset Integer: Offset to map pointNum to mask list index
#' @param out_dir String: Directory to save files
plot_spatial_map <- function(point_num, seg_list, data_df, fill_col, fill_type = "discrete", 
                             palette = NULL, mask_offset = 2, out_dir = NULL) {
  
  require(reshape2)
  require(ggplot2)
  
  # Filter data for current point
  current_data <- data_df %>% filter(pointNum == point_num)
  if(nrow(current_data) == 0) return(NULL)
  
  # Metadata for title
  pid <- unique(current_data$patientID)
  region_or_fov <- if("fov" %in% names(current_data) && !all(is.na(current_data$fov))) {
    unique(current_data$fov)
  } else {
    unique(current_data$region)
  }
  plot_title <- paste0(pid, '_', region_or_fov)
  
  # Get Mask
  mask_idx <- point_num - mask_offset
  if(mask_idx < 1 || mask_idx > length(seg_list)) return(NULL)
  seg_mat <- seg_list[[mask_idx]]
  
  # Create LUT
  lut <- current_data %>% dplyr::select(cellLabel, all_of(fill_col))
  colnames(lut) <- c("cellLabel", "value_to_plot")
  
  # Melt and Map
  mat_long <- melt(seg_mat)
  mat_long$fill_val <- lut$value_to_plot[match(mat_long$value, lut$cellLabel)]
  
  # Base Plot
  p <- ggplot() +
    geom_raster(data = mat_long, aes(x = Var2, y = -Var1, fill = fill_val)) +
    theme_void() +
    theme(legend.position = ifelse(fill_type == "continuous", "right", "none"))
  
  # Apply Scales
  if (fill_type == "discrete") {
    p <- p + scale_fill_manual(values = palette, na.value = "white", drop = FALSE)
  } else {
    p <- p + scale_fill_viridis_c(option = 'plasma', na.value = 'white') +
      labs(fill = 'Score')
  }
  
  # Save
  if (!is.null(out_dir)) {
    if(!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
    ggsave(filename = file.path(out_dir, paste0(plot_title, '.png')), 
           plot = p, device = 'png', height = 9, width = 9, units = 'in', dpi = 320)
  }
  
  return(TRUE)
}

```

## 2.3 Exhaustion Analysis

```{r func_exhaustion}
#' Calculate Immune Exhaustion Scores (Score V3)
calculate_exhaustion_scores <- function(df) {
  # Filter relevant immune cells
  immune_df <- df %>% 
    filter(Annotation %in% c('CD4', 'CD8', 'DC', 'M1', 'M2', 'Cytotoxic CD4', 'Cytotoxic CD8', 'Treg'))
  
  # Calculate Score V3 based on markers
  immune_df <- immune_df %>% 
    mutate(exhaustion_score_v3 = case_when(
      Annotation %in% c('CD4', 'CD8', 'Cytotoxic CD4', 'Cytotoxic CD8', 'Treg') ~ 
        CD45RO - CD45RA + Tox + `PD-1` - `Ki-67` + Lag3,
      Annotation %in% c('DC', 'M1', 'M2') ~ 
        `PD-L1` - `Ki-67`,
      TRUE ~ NA_real_
    ))
  
  return(immune_df)
}

#' Plot Paired Exhaustion Trends
plot_exhaustion_trends <- function(df, output_path) {
  
  cell_types <- unique(df$Annotation)
  
  for (ctype in cell_types) {
    
    celltype_data <- df %>% 
      filter(Annotation == ctype, bin_deriva != 'Far')
    
    if (nrow(celltype_data) <= 1) next
    
    # Aggregate mean score per point/bin/status
    summary_data <- celltype_data %>% 
      group_by(pointNum, bin_deriva, ebv_status) %>% 
      summarise(score_avg = mean(exhaustion_score_v3, na.rm = TRUE), .groups = "drop")
    
    # Calculate difference direction for line coloring
    plot_data <- summary_data %>%
      mutate(
        ebv_status = factor(ebv_status, levels = c('Positive', 'Negative')),
        bin_deriva = factor(bin_deriva, levels = c('Tumor Dense', 'Tumor Sparse'))
      ) %>% 
      group_by(pointNum) %>% 
      arrange(bin_deriva) %>% 
      mutate(diff = lag(score_avg) - score_avg) %>% 
      fill(diff, .direction = "updown") %>%
      mutate(diff_dir = ifelse(diff > 0, 'greater', 'less')) 
    
    # Plot
    p <- ggplot(plot_data, aes(x = interaction(bin_deriva, ebv_status), y = score_avg, fill = bin_deriva)) +
      geom_boxplot(outlier.alpha = 0) +
      geom_point(alpha = 0.5) +
      geom_line(aes(group = interaction(pointNum, ebv_status), linetype = diff_dir, color = diff_dir), alpha = 0.3) +
      scale_fill_manual(values = c('#f6adff', '#e1d936')) +
      scale_color_manual(values = c("#f228a0", "#096013")) +
      theme_bw() +
      theme(axis.text = element_text(size = 12),
            legend.position = 'none',
            axis.text.x = element_text(angle = -30, hjust = 0)) +
      labs(y = 'Exhaustion Score', x = 'Bin', title = ctype)
    
    if(!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)
    ggsave(filename = file.path(output_path, paste0(ctype, '.pdf')), 
           p, width = 5, height = 10, units = 'cm', dpi = 320)
  }
}

```

# 3. Main Analysis Execution

## 3.1 Load and Process Data

```{r load_data}
merged_data <- load_project_data(PATHS$annotated_data, PATHS$tumor_score)
processed_data <- process_annotations_for_plotting(merged_data)
mask_list <- prepare_masks(PATHS$seg_dir)

cat("Data Loaded Successfully.\n")
cat("Total Rows:", nrow(processed_data), "\n")

```

## 3.2 Figure 4B: Generate Spatial Maps

This section uses parallel processing to generate raster maps for bins and scores.

```{r fig4b_maps, eval=FALSE}
# Wrapper to orchestrate parallel plotting
run_parallel_plotting <- function(data_subset, fill_col, fill_type, palette, offset, out_subdir) {
  # Initialize Cluster
  n_cores <- parallel::detectCores() - 2 # Use available cores minus 2
  cl <- parallel::makeCluster(n_cores) 
  doParallel::registerDoParallel(cl)
  
  message(paste("Starting parallel plot generation for:", out_subdir))
  
  foreach(i = unique(data_subset$pointNum), .packages = c('dplyr', 'ggplot2', 'reshape2')) %dopar% {
    plot_spatial_map(
      point_num = i,
      seg_list = mask_list,
      data_df = data_subset,
      fill_col = fill_col,
      fill_type = fill_type,
      palette = palette,
      mask_offset = offset,
      out_dir = file.path(PATHS$output_dir, out_subdir)
    )
  }
  
  parallel::stopCluster(cl)
  message(paste("Finished:", out_subdir))
}

# --- Execution ---

# 1. Discrete Bin Maps (Whole Region)
subset_region <- processed_data %>% filter(is.na(fov))
run_parallel_plotting(subset_region, "bin_deriva", "discrete", PALETTES$bin_discrete, 2, "bin_map_tangent_no_legend")

# 2. Discrete Bin Maps (Single FOV)
subset_fov <- processed_data %>% filter(!is.na(fov))
run_parallel_plotting(subset_fov, "bin_deriva", "discrete", PALETTES$bin_discrete, 34, "bin_map_tangent_singleFOV")

# 3. Continuous Score Maps (Whole Region)
run_parallel_plotting(subset_region, "score", "continuous", NULL, 2, "score_map_072723")

# 4. Continuous Score Maps (Single FOV)
run_parallel_plotting(subset_fov, "score", "continuous", NULL, 34, "score_map_singleFOV_073123")

```

## 3.3 Figure 4C: Immune Exhaustion

```{r fig4c_exhaustion}
exhaustion_df <- calculate_exhaustion_scores(processed_data)
plot_exhaustion_trends(exhaustion_df, file.path(PATHS$output_dir, "figure4/figure4c/"))

```

## 3.4 KNN Imputation & Proliferation Analysis

Imputing tumor spatial context (Dense/Sparse) for tumor cells based on neighboring cells using KNN.

```{r knn_imputation}
set.seed(123)

# Define Reference Sets
data_tumor <- processed_data %>% filter(Annotation == 'Tumor')
data_nontumor <- processed_data %>% 
  filter(Annotation != 'Tumor', bin_deriva %in% c('Tumor Dense', 'Tumor Sparse'))

# Run KNN per point
tumor_imputed_list <- list()

for (i in unique(processed_data$pointNum)) {
  train <- data_nontumor %>% filter(pointNum == i)
  test  <- data_tumor %>% filter(pointNum == i)
  
  if(nrow(train) > 0 && nrow(test) > 0) {
    knn_res <- knn(
      train = train[, c('centroidX', 'centroidY')],
      test  = test[, c('centroidX', 'centroidY')],
      cl    = train$bin_deriva,
      k     = 20
    )
    test$tumor_region <- knn_res
    tumor_imputed_list[[as.character(i)]] <- test %>% dplyr::select(pointNum, cellLabel, tumor_region)
  }
}

# Update Tumor Data
tumor_region_lut <- do.call(rbind, tumor_imputed_list)
data_tumor <- data_tumor %>% left_join(tumor_region_lut, by = c('pointNum', 'cellLabel'))

```

## 3.5 Proliferation Statistics (Ki-67)

### Proportion of Proliferating Tumor Cells

```{r prolif_proportion}
PROLIF_THRESHOLD <- 0.2

tumor_stats <- data_tumor %>% 
  filter(tumor_region == 'Tumor Dense') %>% 
  mutate(prolif = `Ki-67` > PROLIF_THRESHOLD) 

# Boxplot of Proliferation Proportion by EBV Status
p_prolif <- tumor_stats %>% 
  group_by(pointNum, ebv_status, prolif) %>% 
  tally() %>% 
  group_by(pointNum, ebv_status) %>% 
  mutate(prop = n / sum(n)) %>% 
  filter(prolif == TRUE) %>% 
  ggplot(aes(x = ebv_status, y = prop, fill = ebv_status)) + 
  geom_boxplot(outlier.alpha = 0) + 
  geom_point() +
  stat_compare_means(comparisons = list(c('Positive', 'Negative')), 
                     method.args = list(alternative = 'less'), label = 'p.signif') + 
  scale_fill_manual(values = PALETTES$ebv) + 
  theme_bw() +
  labs(x = 'EBV Status', y = 'Proportion of Proliferating Tumor')

print(p_prolif)

```

### Mean Ki-67 Intensity

```{r prolif_intensity}
p_intensity <- tumor_stats %>% 
  filter(prolif) %>% 
  group_by(pointNum, ebv_status) %>% 
  summarise(mean_prolif = mean(`Ki-67`)) %>% 
  ungroup() %>% 
  mutate(ebv_status = factor(ebv_status, levels = c('Positive', 'Negative'))) %>% 
  ggplot(aes(x = ebv_status, y = mean_prolif, fill = ebv_status)) + 
  geom_boxplot(outlier.alpha = 0) + 
  geom_point() + 
  stat_compare_means(comparisons = list(c('Positive', 'Negative')),
                     method.args = list(alternative = 'less'), label = 'p.signif') + 
  theme_bw() + 
  scale_fill_manual(values = PALETTES$ebv) +
  labs(x = 'EBV Status', y = 'Mean Ki-67 Intensity')

print(p_intensity)

```

### Ki-67 Histogram Distribution

```{r prolif_histogram}
p_hist <- tumor_stats %>% 
  ggplot(aes(x = `Ki-67`, fill = as.factor(pointNum))) + 
  geom_histogram(bins = 100, alpha = 0.5) + 
  theme_bw() +
  labs(fill = "Point ID", title = "Ki-67 Distribution across Points")

print(p_hist)

```
